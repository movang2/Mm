<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tr√¨nh ƒë·ªçc file SRT/TXT (C√≥ Th√¥ng B√°o)</title>
  <style>
    /* CSS gi·ªØ nguy√™n nh∆∞ c≈© */
    body { 
      font-family: sans-serif; 
      margin: 0; 
      padding: 20px; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      background: black; 
      color: white; 
      transition: 0.3s;
      min-height: 120vh;
      overflow-x: hidden;
    }
    #clock { font-size: 4em; margin-top: 20px; font-weight: bold; text-align: center; }
    #date { font-size: 1.2em; text-align: center; margin-bottom: 10px; }
    #controls { margin: 10px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; transition: 0.3s; }
    button, input[type="range"], input[type="number"], .setting-group { padding: 6px 12px; font-size: 1em; cursor: pointer; border-radius: 8px; border: none;}
    #pushNotificationBtn { background: linear-gradient(135deg, #1565c0, #6a1b9a); color: white; font-weight: bold; }
    #pushNotificationBtn.active { background: linear-gradient(135deg, #2e7d32, #43a047); }
    .setting-group { background: #333; color: white; display: flex; align-items: center; gap: 5px; }
    input[type="number"] { background: #444; color: white; border: 1px solid #555; width: 50px; text-align: center;}
    #displayArea {
      max-height: 60vh;
      width: 90%;
      overflow-y: auto;
      padding: 1rem;
      background: #111;
      border: 1px solid #444;
      font-size: 1.2em;
      line-height: 1.6;
      white-space: pre-wrap;
      transition: height 0.3s, max-height 0.3s;
    }

    /* === NEW STYLES FOR SRT MODE === */
    #displayArea.srt-mode {
        display: flex;
        flex-direction: column;
        justify-content: center; /* Center the segment vertically */
        align-items: flex-start;
        text-align: left;
        overflow-y: hidden; /* Prevent scrolling in SRT segment mode */
    }
    .srt-segment { 
        margin-bottom: 25px; 
        border-left: 5px solid #0af; 
        padding-left: 15px;
    }
    .srt-time { 
        font-size: 0.9em; 
        color: #888; 
        margin-bottom: 5px;
        display: block;
        font-family: monospace;
    }
    .srt-korean { 
        font-weight: bold; 
        color: #f7f7f7; 
        font-size: 1.4em;
        line-height: 1.4;
        margin-bottom: 5px;
    }
    .srt-vietnamese { 
        color: #b0e0ff; 
        font-style: italic; 
        font-size: 1.1em;
    }
    /* =============================== */

    #scrollSlider { width: 90%; margin: 10px 0; accent-color: #0af; }
    #bubble {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #0af;
      color: white;
      padding: 12px;
      border-radius: 50%;
      font-size: 1.2em;
      cursor: move;
      display: none;
      user-select: none;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }
    #paragraphInfo {
      margin: 10px 0;
      font-size: 1em;
      color: #ccc;
    }
    .scroll-padding {
      height: 100px;
      width: 100%;
      opacity: 0;
      pointer-events: none;
    }
    .toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(30,30,30,0.95); padding: 12px 24px; border-radius: 30px; opacity: 0; transition: 0.3s; pointer-events: none; border: 1px solid #555; z-index: 10000; font-weight: bold; color: white;}
    .toast.show { opacity: 1; }
  </style>
</head>
<body>
  <div class="scroll-padding"></div>

  <div id="clock">00:00</div>
  <div id="date">-- -- ----</div>

  <h2>üìÑ Tr√¨nh ƒë·ªçc file SRT/TXT</h2>
  <input type="file" id="fileInput" accept=".txt,.srt">

  <div id="controls">
    <button onclick="toggleScroll()">‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu / ‚è∏Ô∏è D·ª´ng</button>
    <button onclick="toggleMode()" id="modeBtn">üìñ Ch·∫ø ƒë·ªô t·ª´ng ƒëo·∫°n</button>
    <button onclick="clearProgress()" title="X√≥a ti·∫øn tr√¨nh ƒë√£ l∆∞u">üßπ X√≥a ti·∫øn tr√¨nh</button>
    <button id="pushNotificationBtn">üîî B·∫≠t th√¥ng b√°o</button> 
    
    <div class="setting-group">‚åö C·ª° ƒêH: <input type="range" min="2" max="8" value="4" step="0.1" id="clockSize"></div>
    <div class="setting-group">üìè Cao khung: <input type="range" min="30" max="90" value="60" id="areaHeight"></div>
    
    <div class="setting-group" id="speedGroup">üöÄ T·ªëc ƒë·ªô (TXT): <input type="range" min="1" max="10" value="3" id="speedRange"></div>
    
    <label id="paragraphTimeLabel" style="display: none;" class="setting-group">‚è±Ô∏è Tg/ƒëo·∫°n (s): <input type="number" min="1" max="60" value="3" id="paragraphTime"></label>
    
    <div class="setting-group" id="maxCharsDisplayGroup" style="display: none;">
        <label for="maxCharsPerDisplay">üî† Max Ch·ªØ Hi·ªÉn Th·ªã (TXT):</label> 
        <input type="number" min="50" max="5000" value="500" id="maxCharsPerDisplay">
    </div>
    
    <div class="setting-group">üìù Max Ch·ªØ th√¥ng b√°o: <input type="number" min="10" max="500" id="maxCharsPerNotif" value="100"></div> 
  </div>

  <div id="paragraphInfo"></div>

  <input type="range" min="0" max="100" value="0" id="scrollSlider">

  <div id="displayArea">üìÇ Vui l√≤ng ch·ªçn file TXT ho·∫∑c SRT ƒë·ªÉ hi·ªÉn th·ªã n·ªôi dung...</div>

  <div id="bubble" onclick="restoreControls()">‚è∏Ô∏è</div>
  <div id="toast" class="toast"></div>

  <script>
    let scrolling = false;
    let interval;
    let paragraphMode = false;
    let segments = []; // ƒê·ªïi t√™n t·ª´ 'paragraphs' th√†nh 'segments'
    let currentParagraphIndex = 0;
    let currentFileName = '';
    let fullTextContent = ''; 
    let pushEnabled = false; 
    let isSrtFile = false; // Bi·∫øn m·ªõi ƒë·ªÉ ki·ªÉm tra lo·∫°i file
    
    const displayArea = document.getElementById("displayArea");
    const slider = document.getElementById("scrollSlider");
    const bubble = document.getElementById("bubble");
    const controls = document.getElementById("controls");
    const paragraphInfo = document.getElementById("paragraphInfo");
    const notifBtn = document.getElementById('pushNotificationBtn');
    const toastEl = document.getElementById('toast');
    const maxCharsDisplayInput = document.getElementById("maxCharsPerDisplay");
    const maxCharsDisplayGroup = document.getElementById("maxCharsDisplayGroup");


    const SESSION_ID = 'text_reader_' + Date.now();
    const DEFAULT_TEXT = 'üìÇ Vui l√≤ng ch·ªçn file TXT ho·∫∑c SRT ƒë·ªÉ hi·ªÉn th·ªã n·ªôi dung...';


    window.addEventListener('load', function() {
      setTimeout(() => {
        window.scrollTo(0, 50);
        restoreProgress(); 
      }, 100);
    });

    // --- UTILITIES ---

    function showToast(msg) { 
        toastEl.textContent=msg; 
        toastEl.classList.add('show'); 
        setTimeout(()=>toastEl.classList.remove('show'),3000); 
    }

    /**
     * C·∫Øt vƒÉn b·∫£n th√¥ng minh t·∫°i d·∫•u c√°ch g·∫ßn nh·∫•t.
     */
    function smartTruncate(text, maxChars, addEllipsis = false) {
        if (text.length <= maxChars) {
            return text;
        }
        let truncated = text.substring(0, maxChars);
        const lastSpace = truncated.lastIndexOf(' ');
        
        if (lastSpace !== -1) {
            const result = truncated.substring(0, lastSpace);
            return addEllipsis ? result + '...' : result;
        }
        return addEllipsis ? truncated + '...' : truncated; 
    }
    
    /**
     * H√†m ph√¢n t√≠ch c√∫ ph√°p file SRT (Ch·ªâ d√†nh cho SRT song ng·ªØ 2 d√≤ng)
     * @param {string} srtContent - N·ªôi dung file SRT
     * @returns {Array<Object>} - M·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng segment ƒë√£ ph√¢n t√≠ch
     */
    function parseSrt(srtContent) {
        const lines = srtContent.split('\n');
        const newSegments = [];
        let currentSegment = {};

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            if (!line) {
                // K·∫øt th√∫c segment
                if (currentSegment.korean && currentSegment.vietnamese) {
                    newSegments.push(currentSegment);
                }
                currentSegment = {};
                continue;
            }

            // 1. Segment Index (B·ªè qua ho·∫∑c d√πng ƒë·ªÉ ki·ªÉm tra)
            if (!isNaN(parseInt(line)) && !currentSegment.index) {
                currentSegment.index = parseInt(line);
                continue;
            }

            // 2. Timestamps
            if (line.includes('-->') && !currentSegment.start) {
                const parts = line.split('-->');
                currentSegment.start = parts[0].trim();
                currentSegment.end = parts[1].trim();
                continue;
            }

            // 3. Korean/Vietnamese text (Gi·∫£ s·ª≠ d√≤ng ƒë·∫ßu l√† H√†n, d√≤ng sau l√† Vi·ªát)
            if (currentSegment.index && currentSegment.start) {
                if (!currentSegment.korean) {
                    currentSegment.korean = line;
                } else if (!currentSegment.vietnamese) {
                    currentSegment.vietnamese = line;
                }
            }
        }
        // Th√™m segment cu·ªëi c√πng n·∫øu c√≥
        if (currentSegment.korean && currentSegment.vietnamese) {
            newSegments.push(currentSegment);
        }
        return newSegments;
    }

    /**
     * Logic M·ªöI: T·ª± ƒë·ªông chia ƒëo·∫°n d√†i th√†nh c√°c ƒëo·∫°n con (ch·ªâ d√πng cho TXT).
     */
    function preprocessParagraphs(rawParagraphs) {
        if (isSrtFile) return []; // B·ªè qua n·∫øu l√† SRT
        
        const maxChars = parseInt(maxCharsDisplayInput.value) || 500;
        const processed = [];

        rawParagraphs.forEach(p => {
            let currentText = p.trim();
            if (currentText.length === 0) return;

            // N·∫øu ƒëo·∫°n qu√° ng·∫Øn, ch·ªâ th√™m n√≥ v√†o.
            if (currentText.length <= maxChars) {
                processed.push(currentText + '.');
                return;
            }

            // Chia nh·ªè ƒëo·∫°n d√†i
            while (currentText.length > 0) {
                const segment = smartTruncate(currentText, maxChars, false); 
                
                if (segment.length === 0 && currentText.length > 0) {
                    const hardCut = currentText.substring(0, maxChars);
                    processed.push(hardCut);
                    currentText = currentText.substring(maxChars).trim();
                } else if (segment.length > 0) {
                    processed.push(segment + '.'); 
                    currentText = currentText.substring(segment.length).trim();
                } else {
                    break;
                }
            }
        });
        return processed;
    }


    // --- L∆ØU V√Ä KH√îI PH·ª§C TR·∫†NG TH√ÅI ---

    function saveProgress() {
      const progress = {
        sessionId: SESSION_ID,
        fileName: currentFileName,
        content: fullTextContent, 
        paragraphMode: paragraphMode,
        currentParagraphIndex: currentParagraphIndex,
        scrollPosition: displayArea.scrollTop,
        scrollPercentage: slider.value,
        clockSize: document.getElementById("clockSize").value,
        areaHeight: document.getElementById("areaHeight").value,
        speed: document.getElementById("speedRange").value,
        paragraphTime: document.getElementById("paragraphTime").value, 
        maxCharsPerNotif: document.getElementById("maxCharsPerNotif").value, 
        maxCharsPerDisplay: maxCharsDisplayInput.value,
        isPushEnabled: pushEnabled, 
        isSrtFile: isSrtFile, // L∆∞u tr·∫°ng th√°i lo·∫°i file
        timestamp: Date.now()
      };
      
      localStorage.setItem('textReaderProgress', JSON.stringify(progress));
    }

    function restoreProgress() {
      const saved = localStorage.getItem('textReaderProgress');
      if (!saved) return;

      const progress = JSON.parse(saved);
      if (progress.sessionId && progress.sessionId !== SESSION_ID) return;

      isSrtFile = progress.isSrtFile || false;
      
      // ·∫®n/hi·ªán c√°c control ch·ªâ d√†nh cho TXT
      maxCharsDisplayGroup.style.display = isSrtFile ? 'none' : 'flex';
      document.getElementById("speedGroup").style.display = isSrtFile ? 'none' : 'flex';

      if (progress.content && progress.content !== DEFAULT_TEXT) {
        fullTextContent = progress.content; 
        currentFileName = progress.fileName || '';
        
        if (isSrtFile) {
            segments = parseSrt(fullTextContent);
        } else {
            // T√°i t·∫°o segments (paragraphs) cho TXT
            const rawParagraphs = fullTextContent.split(/[.!?]+/).filter(p => p.trim().length > 0);
            segments = preprocessParagraphs(rawParagraphs); 
        }
      } else {
        fullTextContent = '';
        segments = [];
      }

      if (progress.paragraphMode !== undefined) {
        paragraphMode = progress.paragraphMode;
        document.getElementById("modeBtn").textContent = paragraphMode ? "üìú Ch·∫ø ƒë·ªô cu·ªôn li√™n t·ª•c" : "üìñ Ch·∫ø ƒë·ªô t·ª´ng ƒëo·∫°n";
        document.getElementById("paragraphTimeLabel").style.display = paragraphMode ? "flex" : "none";
        
        // Th√™m class cho SRT mode ƒë·ªÉ ƒëi·ªÅu ch·ªânh displayArea
        displayArea.classList.toggle('srt-mode', paragraphMode && isSrtFile);
        
        // Kh√¥i ph·ª•c c√†i ƒë·∫∑t tr∆∞·ªõc khi g·ªçi showCurrentParagraph
        if (progress.maxCharsPerDisplay) maxCharsDisplayInput.value = progress.maxCharsPerDisplay; 

        if (paragraphMode && segments.length > 0 && progress.currentParagraphIndex !== undefined) {
          currentParagraphIndex = progress.currentParagraphIndex;
          showCurrentParagraph(false);
        } else if (!paragraphMode) {
            displayArea.textContent = fullTextContent;
            if (progress.scrollPosition !== undefined) {
              setTimeout(() => {
                displayArea.scrollTop = progress.scrollPosition;
                slider.value = progress.scrollPercentage || 0;
              }, 100);
            }
        }
      }

      // Kh√¥i ph·ª•c c√†i ƒë·∫∑t kh√°c
      if (progress.clockSize) document.getElementById("clockSize").value = progress.clockSize;
      if (progress.areaHeight) document.getElementById("areaHeight").value = progress.areaHeight;
      if (progress.speed) document.getElementById("speedRange").value = progress.speed;
      if (progress.paragraphTime) document.getElementById("paragraphTime").value = progress.paragraphTime;
      if (progress.maxCharsPerNotif) document.getElementById("maxCharsPerNotif").value = progress.maxCharsPerNotif; 

      if (progress.isPushEnabled) {
          pushEnabled = true;
          notifBtn.innerHTML = "üîî ƒê√£ b·∫≠t"; 
          notifBtn.classList.add('active');
      }

      document.getElementById("clock").style.fontSize = document.getElementById("clockSize").value + "em";
      displayArea.style.maxHeight = document.getElementById("areaHeight").value + "vh";

      updateParagraphInfo();
      updateSliderForParagraphs();
    }


    // Load file TXT/SRT
    document.getElementById("fileInput").addEventListener("change", function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      currentFileName = file.name;
      isSrtFile = file.name.toLowerCase().endsWith('.srt');
      
      // ·∫®n/hi·ªán c√°c control ch·ªâ d√†nh cho TXT
      maxCharsDisplayGroup.style.display = isSrtFile ? 'none' : 'flex';
      document.getElementById("speedGroup").style.display = isSrtFile ? 'none' : 'flex';
      
      const reader = new FileReader();
      reader.onload = function(ev) {
        fullTextContent = ev.target.result;
        
        if (isSrtFile) {
            // SRT mode: segments l√† c√°c block ph·ª• ƒë·ªÅ
            segments = parseSrt(fullTextContent);
            paragraphMode = true; // B·∫≠t c·ªë ƒë·ªãnh ch·∫ø ƒë·ªô t·ª´ng ƒëo·∫°n cho SRT
            document.getElementById("modeBtn").textContent = "üìú Ch·∫ø ƒë·ªô cu·ªôn li√™n t·ª•c";
            document.getElementById("paragraphTimeLabel").style.display = "flex";
            displayArea.classList.add('srt-mode');
            showToast(`ƒê√£ t·∫£i file SRT "${file.name}". B·∫≠t ch·∫ø ƒë·ªô T·ª´ng ƒêo·∫°n.`);

        } else {
            // TXT mode: d√πng l·∫°i logic chia ƒëo·∫°n c≈©
            const rawParagraphs = fullTextContent.split(/[.!?]+/).filter(p => p.trim().length > 0);
            segments = preprocessParagraphs(rawParagraphs); 
            displayArea.classList.remove('srt-mode');
            showToast(`ƒê√£ t·∫£i file TXT "${file.name}"`);
        }

        currentParagraphIndex = 0;
        
        if (paragraphMode) {
            showCurrentParagraph(false);
        } else {
            displayArea.textContent = fullTextContent;
        }

        updateParagraphInfo();
        updateSliderForParagraphs();
        saveProgress(); 
      };
      reader.readAsText(file);
    });

    // --- LOGIC CHUY·ªÇN ƒêO·∫†N/CU·ªòN ---
    
    function updateParagraphInfo() {
        if (paragraphMode && segments.length > 0) {
            paragraphInfo.style.display = 'block';
            paragraphInfo.textContent = `ƒêo·∫°n ${currentParagraphIndex + 1} / ${segments.length}`;
        } else {
            paragraphInfo.style.display = 'none';
        }
    }

    function updateSliderForParagraphs() {
        if (paragraphMode && segments.length > 1) {
            slider.min = 0;
            slider.max = segments.length - 1;
            slider.value = currentParagraphIndex;
            slider.style.display = 'block';
        } else if (!paragraphMode && fullTextContent) {
            slider.min = 0;
            slider.max = 100;
            slider.style.display = 'block';
        } else {
            slider.style.display = 'none';
        }
    }

    function toggleMode() {
      if (fullTextContent.length === 0) {
        showToast('Vui l√≤ng ch·ªçn file TXT/SRT tr∆∞·ªõc khi chuy·ªÉn ch·∫ø ƒë·ªô.');
        return;
      }
      
      // Kh√¥ng cho ph√©p chuy·ªÉn mode n·∫øu l√† file SRT (lu√¥n ·ªü ch·∫ø ƒë·ªô segment)
      if (isSrtFile) {
          showToast('Ch·∫ø ƒë·ªô T·ª´ng ƒêo·∫°n ƒë∆∞·ª£c k√≠ch ho·∫°t c·ªë ƒë·ªãnh cho file SRT. Vui l√≤ng t·∫£i file TXT ƒë·ªÉ chuy·ªÉn ch·∫ø ƒë·ªô.');
          return;
      }

      paragraphMode = !paragraphMode;
      const modeBtn = document.getElementById("modeBtn");
      const paragraphTimeLabel = document.getElementById("paragraphTimeLabel");
      
      if (paragraphMode) {
        modeBtn.textContent = "üìú Ch·∫ø ƒë·ªô cu·ªôn li√™n t·ª•c";
        paragraphTimeLabel.style.display = "flex";
        
        // T√°i t·∫°o segments (paragraphs) d·ª±a tr√™n c√†i ƒë·∫∑t maxCharsPerDisplay hi·ªán t·∫°i
        const rawParagraphs = fullTextContent.split(/[.!?]+/).filter(p => p.trim().length > 0);
        segments = preprocessParagraphs(rawParagraphs); 
        currentParagraphIndex = 0;

        if (segments.length > 0) {
          showCurrentParagraph();
        }
      } else {
        modeBtn.textContent = "üìñ Ch·∫ø ƒë·ªô t·ª´ng ƒëo·∫°n";
        paragraphTimeLabel.style.display = "none";
        displayArea.textContent = fullTextContent; 
        displayArea.scrollTop = 0; 
      }
      updateParagraphInfo();
      updateSliderForParagraphs();
      saveProgress(); 
    }

    /**
     * Hi·ªÉn th·ªã ƒëo·∫°n/segment hi·ªán t·∫°i (H·ªó tr·ª£ c·∫£ SRT v√† TXT)
     */
    function showCurrentParagraph(shouldSave = true) {
      if (segments.length > 0 && currentParagraphIndex < segments.length) {
        const currentSegment = segments[currentParagraphIndex];

        let displayContent;
        let notificationBody = '';

        if (isSrtFile) {
            // SRT Mode: Format output as Timestamp -> Korean -> Vietnamese
            displayContent = `
                <div class="srt-segment">
                    <span class="srt-time">${currentSegment.start} --> ${currentSegment.end}</span>
                    <div class="srt-korean">${currentSegment.korean}</div>
                    <div class="srt-vietnamese">${currentSegment.vietnamese}</div>
                </div>
            `;
            // N·ªôi dung th√¥ng b√°o bao g·ªìm c·∫£ 2 ng√¥n ng·ªØ
            notificationBody = `${currentSegment.korean} | ${currentSegment.vietnamese}`;
            
            displayArea.innerHTML = displayContent;
            
        } else {
            // TXT Mode (original logic): Display only the paragraph text
            displayContent = currentSegment; 
            displayArea.textContent = displayContent;
            
            // Notification body uses the smartTruncate logic for TXT
            notificationBody = smartTruncate(displayContent, parseInt(document.getElementById("maxCharsPerNotif").value) || 100, true); 
        }

        // G·ª≠i th√¥ng b√°o (ch·ªâ ·ªü ch·∫ø ƒë·ªô ƒëo·∫°n)
        if (pushEnabled) {
            const maxCharsNotif = parseInt(document.getElementById("maxCharsPerNotif").value) || 100;
            const finalNotifBody = smartTruncate(notificationBody, maxCharsNotif, true); 
            const title = `ƒê·ªçc: ƒêo·∫°n ${currentParagraphIndex + 1}/${segments.length}`;
            sendNotification(title, finalNotifBody);
        }

        updateParagraphInfo();
        updateSliderForParagraphs();
        if (shouldSave) saveProgress(); 
      }
    }

    function nextParagraph() {
      if (currentParagraphIndex < segments.length - 1) {
        currentParagraphIndex++;
        showCurrentParagraph();
      }
    }
    
    function previousParagraph() {
      if (currentParagraphIndex > 0) {
        currentParagraphIndex--;
        showCurrentParagraph();
      }
    }


    function toggleScroll() {
      if (fullTextContent.length === 0) {
        showToast('Vui l√≤ng ch·ªçn file TXT/SRT tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu cu·ªôn/ƒë·ªçc t·ª± ƒë·ªông.');
        return;
      }
      
      scrolling = !scrolling;
      const scrollBtn = document.querySelector("#controls button");

      if (scrolling) {
        scrollBtn.textContent = '‚è∏Ô∏è D·ª´ng';
        controls.style.display = "none";
        bubble.style.display = "block";
        document.querySelector("h2").style.display = "none";
        document.getElementById("fileInput").style.display = "none";
        paragraphInfo.style.display = "none";
        
        if (!paragraphMode && pushEnabled) {
             sendNotification('üöÄ B·∫Øt ƒë·∫ßu cu·ªôn', 'M√†n h√¨nh s·∫Ω cu·ªôn li√™n t·ª•c...');
        }

        if (paragraphMode) {
          // Ch·∫ø ƒë·ªô T·ª´ng ƒêo·∫°n (SRT ho·∫∑c TXT)
          const paragraphTime = parseFloat(document.getElementById("paragraphTime").value) * 1000; 
          interval = setInterval(() => {
            // N·∫øu ƒë√£ ƒë·∫øn ƒëo·∫°n cu·ªëi, d·ª´ng l·∫°i
            if (currentParagraphIndex >= segments.length - 1) { 
                 restoreControls();
                 showToast("ƒê√£ ho√†n th√†nh to√†n b·ªô n·ªôi dung.");
                 return;
            }
            nextParagraph();
          }, paragraphTime);
        } else {
          // Ch·∫ø ƒë·ªô Cu·ªôn Li√™n T·ª•c (Ch·ªâ TXT)
          interval = setInterval(() => {
            if (displayArea.scrollTop >= (displayArea.scrollHeight - displayArea.clientHeight)) {
                restoreControls(); 
                return;
            }
            displayArea.scrollTop += parseInt(document.getElementById("speedRange").value);
            slider.value = (displayArea.scrollTop / (displayArea.scrollHeight - displayArea.clientHeight)) * 100;
            saveProgress(); 
          }, 100);
        }
      } else {
        scrollBtn.textContent = '‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu / ‚è∏Ô∏è D·ª´ng';
        clearInterval(interval);
        saveProgress(); 
      }
    }
    
    function restoreControls() {
      clearInterval(interval);
      scrolling = false;
      controls.style.display = "flex";
      bubble.style.display = "none";
      document.querySelector("h2").style.display = "block";
      document.getElementById("fileInput").style.display = "block";
      document.querySelector("#controls button").textContent = '‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu / ‚è∏Ô∏è D·ª´ng';
      updateParagraphInfo();
      saveProgress(); 
    }
    
    function sendNotification(title, body) {
      if (!pushEnabled) return;
      const icon = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3EüìÑ%3C/text%3E%3C/svg%3E";
      
      navigator.serviceWorker.ready.then(reg => {
          reg.showNotification(title, { 
              body: body, 
              icon: icon, 
              tag: 'text-reader-app', 
              renotify: true, 
              vibrate: [100, 50, 100],
              silent: false 
          });
      });
    }

    notifBtn.addEventListener('click', async () => {
      if (!('serviceWorker' in navigator) || !('Notification' in window)) return showToast("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ th√¥ng b√°o.");
      const permission = await Notification.requestPermission();
      if (permission !== 'granted') return showToast('‚ùå C·∫ßn c·∫•p quy·ªÅn th√¥ng b√°o');

      try {
        await navigator.serviceWorker.register('sw.js'); 
        pushEnabled = true;
        notifBtn.innerHTML = "üîî ƒê√£ b·∫≠t (S·∫µn s√†ng)"; 
        notifBtn.classList.add('active');
        showToast("‚úÖ ƒê√£ b·∫≠t th√¥ng b√°o!");
        sendNotification("üîî S·∫µn s√†ng", "Th√¥ng b√°o s·∫Ω hi·ªán khi chuy·ªÉn ƒëo·∫°n!");
        saveProgress();
      } catch (err) {
        showToast("L·ªói ƒëƒÉng k√Ω Service Worker. H√£y ki·ªÉm tra file sw.js!");
      }
    });

    slider.addEventListener("input", () => {
      if (paragraphMode && segments.length > 1) {
        const paragraphIndex = parseInt(slider.value);
        currentParagraphIndex = paragraphIndex;
        showCurrentParagraph();
      } else if (fullTextContent.length > 0 && !paragraphMode) {
        displayArea.scrollTop = (slider.value / 100) * (displayArea.scrollHeight - displayArea.clientHeight);
        saveProgress(); 
      }
    });

    // L·∫Øng nghe s·ª± ki·ªán input cho c√†i ƒë·∫∑t gi·ªõi h·∫°n hi·ªÉn th·ªã (Ch·ªâ d√πng cho TXT)
    maxCharsDisplayInput.addEventListener("input", function() {
        saveProgress();
        if (paragraphMode && fullTextContent && !isSrtFile) {
            const rawParagraphs = fullTextContent.split(/[.!?]+/).filter(p => p.trim().length > 0);
            segments = preprocessParagraphs(rawParagraphs); 
            currentParagraphIndex = 0;
            showCurrentParagraph();
        }
    });

    document.getElementById("clockSize").addEventListener("input", function() {
      document.getElementById("clock").style.fontSize = this.value + "em";
      saveProgress();
    });

    document.getElementById("areaHeight").addEventListener("input", function() {
      displayArea.style.maxHeight = this.value + "vh";
      saveProgress();
    });

    document.getElementById("speedRange").addEventListener("input", saveProgress);
    document.getElementById("paragraphTime").addEventListener("input", saveProgress); 
    document.getElementById("maxCharsPerNotif").addEventListener("input", saveProgress);

    // H√†m x√≥a ti·∫øn tr√¨nh
    function clearProgress() {
        localStorage.removeItem('textReaderProgress');
        showToast('üßπ ƒê√£ x√≥a ti·∫øn tr√¨nh ƒë√£ l∆∞u.');
        location.reload(); 
    }
    window.clearProgress = clearProgress; // C·∫ßn thi·∫øt ƒë·ªÉ h√†m c√≥ th·ªÉ ƒë∆∞·ª£c g·ªçi t·ª´ HTML

    function updateClock() {
      const now = new Date();
      let h = String(now.getHours()).padStart(2,"0");
      let m = String(now.getMinutes()).padStart(2,"0");
      document.getElementById("clock").textContent = `${h}:${m}`;
      const options = { weekday: 'short', day: '2-digit', month: 'long', year: 'numeric' };
      document.getElementById("date").textContent = now.toLocaleDateString("vi-VN", options);
    }
    setInterval(updateClock, 1000);
    updateClock();

    bubble.addEventListener("mousedown", function(e) {
      let shiftX = e.clientX - bubble.getBoundingClientRect().left;
      let shiftY = e.clientY - bubble.getBoundingClientRect().top;
      function moveAt(pageX, pageY) {
        bubble.style.left = pageX - shiftX + 'px';
        bubble.style.top = pageY - shiftY + 'px';
      }
      function onMouseMove(e) { moveAt(e.pageX, e.pageY); }
      document.addEventListener('mousemove', onMouseMove);
      bubble.onmouseup = function() {
        document.removeEventListener('mousemove', onMouseMove);
        bubble.onmouseup = null;
      };
    });
    bubble.ondragstart = () => false;

    document.addEventListener('keydown', function(e) {
      // Ch·ªâ cho ph√©p ƒëi·ªÅu h∆∞·ªõng b·∫±ng ph√≠m m≈©i t√™n khi ƒëang ·ªü ch·∫ø ƒë·ªô ƒëo·∫°n v√† kh√¥ng cu·ªôn t·ª± ƒë·ªông
      if (fullTextContent.length > 0 && paragraphMode && !scrolling) {
          if (e.key === 'ArrowRight') {
            e.preventDefault();
            nextParagraph();
          } else if (e.key === 'ArrowLeft') {
            e.preventDefault();
            previousParagraph();
          }
      } else if (fullTextContent.length > 0 && e.key === ' ') {
          e.preventDefault();
          toggleScroll();
      }
    });

    window.addEventListener('beforeunload', saveProgress);
  </script>
</body>
</html>
